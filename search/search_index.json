{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Deethon \u00a4 Deethon is a lightweight Python library for downloading high quality music from Deezer. Gettings started \u00a4 Installation \u00a4 pip install deethon Usage \u00a4 import deethon deezer = deethon . Session ( \"YOUR ARL TOKEN\" ) deezer . download ( \"https://www.deezer.com/track/1234567\" , bitrate = \"FLAC\" # or MP3_320 / MP3_256 / MP3_128 (optional) )","title":"Welcome to Deethon"},{"location":"#deethon","text":"Deethon is a lightweight Python library for downloading high quality music from Deezer.","title":"Deethon"},{"location":"#gettings-started","text":"","title":"Gettings started"},{"location":"#installation","text":"pip install deethon","title":"Installation"},{"location":"#usage","text":"import deethon deezer = deethon . Session ( \"YOUR ARL TOKEN\" ) deezer . download ( \"https://www.deezer.com/track/1234567\" , bitrate = \"FLAC\" # or MP3_320 / MP3_256 / MP3_128 (optional) )","title":"Usage"},{"location":"code_of_conduct/","text":"Contributor Covenant Code of Conduct \u00a4 Our Pledge \u00a4 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00a4 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00a4 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00a4 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00a4 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at deethon@aykut.ml. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00a4 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Code of Conduct"},{"location":"code_of_conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at deethon@aykut.ml. All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Attribution"},{"location":"license/","text":"License \u00a4 Deethon - Python library to downlaod music from Deezer Copyright \u00a9 2020 Aykut Yilmaz This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see https://www.gnu.org/licenses/ .","title":"License"},{"location":"license/#license","text":"Deethon - Python library to downlaod music from Deezer Copyright \u00a9 2020 Aykut Yilmaz This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program. If not, see https://www.gnu.org/licenses/ .","title":"License"},{"location":"reference/consts/","text":"\u00a4 This module contains several constants. API_URL: str \u00a4 The url of Deezer's unofficial API server. LEGACY_API_URL: str \u00a4 The url of Deezer's official API server. METHOD_GET_TRACK: str \u00a4 The song.getData method for the Deezer API request. METHOD_GET_USER: str \u00a4 The deezer.getUserData method for the Deezer API request.","title":"consts.py"},{"location":"reference/consts/#deethon.consts","text":"This module contains several constants.","title":"deethon.consts"},{"location":"reference/consts/#deethon.consts.API_URL","text":"The url of Deezer's unofficial API server.","title":"API_URL"},{"location":"reference/consts/#deethon.consts.LEGACY_API_URL","text":"The url of Deezer's official API server.","title":"LEGACY_API_URL"},{"location":"reference/consts/#deethon.consts.METHOD_GET_TRACK","text":"The song.getData method for the Deezer API request.","title":"METHOD_GET_TRACK"},{"location":"reference/consts/#deethon.consts.METHOD_GET_USER","text":"The deezer.getUserData method for the Deezer API request.","title":"METHOD_GET_USER"},{"location":"reference/errors/","text":"\u00a4 The errors module contains all custom error classes ActionNotSupported \u00a4 Raised when an invalid action is called DeezerApiError \u00a4 Raised when a Deezer api request returns an error DeezerLoginError \u00a4 Raised when login to Deezer fails. InvalidUrlError \u00a4 Raised when an invalid url is passed","title":"errors.py"},{"location":"reference/errors/#deethon.errors","text":"The errors module contains all custom error classes","title":"deethon.errors"},{"location":"reference/errors/#deethon.errors.ActionNotSupported","text":"Raised when an invalid action is called","title":"ActionNotSupported"},{"location":"reference/errors/#deethon.errors.DeezerApiError","text":"Raised when a Deezer api request returns an error","title":"DeezerApiError"},{"location":"reference/errors/#deethon.errors.DeezerLoginError","text":"Raised when login to Deezer fails.","title":"DeezerLoginError"},{"location":"reference/errors/#deethon.errors.InvalidUrlError","text":"Raised when an invalid url is passed","title":"InvalidUrlError"},{"location":"reference/session/","text":"\u00a4 This module contains the Session class. Session \u00a4 A session is required to connect to Deezer's unofficial API. __init__ ( self , arl_token ) special \u00a4 Creates a new Deezer session instance. Parameters: Name Type Description Default arl_token str The arl token is used to make API requests on Deezers unofficial API required Source code in deethon\\session.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def __init__ ( self , arl_token : str ): \"\"\" Creates a new Deezer session instance. Args: arl_token (str): The arl token is used to make API requests on Deezers unofficial API \"\"\" self . _arl_token : str = arl_token self . _req = requests . Session () self . _req . cookies [ \"arl\" ] = self . _arl_token user = self . get_api ( consts . METHOD_GET_USER ) if user [ \"USER\" ][ \"USER_ID\" ] == 0 : raise errors . DeezerLoginError self . _csrf_token = user [ \"checkForm\" ] download ( self , url , bitrate = 'FLAC' , progress_callback = None ) \u00a4 Downloads the given Deezer url if possible. Parameters: Name Type Description Default url str The URL of the track or album to download. required bitrate str The preferred bitrate to download ( FLAC , MP3_320 , MP3_256 , MP3_128 ). 'FLAC' progress_callback callable A callable that accepts current and bytes arguments. None Returns: Type Description Path The file path of the downloaded track Source code in deethon\\session.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def download ( self , url : str , bitrate : str = \"FLAC\" , progress_callback = None ): \"\"\" Downloads the given Deezer url if possible. Args: url (str): The URL of the track or album to download. bitrate (str, optional): The preferred bitrate to download (`FLAC`, `MP3_320`, `MP3_256`, `MP3_128`). progress_callback (callable): A callable that accepts `current` and `bytes` arguments. Returns: Path: The file path of the downloaded track \"\"\" match = re . match ( r \"https?://(?:www\\.)?deezer\\.com/(?:\\w+/)?(\\w+)/(\\d+)\" , url ) if match : mode = match . group ( 1 ) content_id = match . group ( 2 ) if mode == \"track\" : return self . download_track ( types . Track ( content_id ), bitrate , progress_callback ) if mode == \"album\" : return self . download_album ( types . Album ( content_id ), bitrate ) raise errors . ActionNotSupported ( mode ) else : raise errors . InvalidUrlError ( url ) download_track ( self , track , bitrate = 'FLAC' , progress_callback = None ) \u00a4 Downloads the given [Track][deethon.types.Track] object. Parameters: Name Type Description Default track Track A [Track][deethon.types.Track] instance. required bitrate str The preferred bitrate to download ( FLAC , MP3_320 , MP3_256 , MP3_128 ). 'FLAC' progress_callback callable A callable that accepts current and bytes arguments. None Returns: Type Description Path Path: The file path of the downloaded track. Source code in deethon\\session.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def download_track ( self , track : types . Track , bitrate : str = \"FLAC\" , progress_callback = None ) -> Path : \"\"\" Downloads the given [Track][deethon.types.Track] object. Args: track: A [Track][deethon.types.Track] instance. bitrate (optional): The preferred bitrate to download (`FLAC`, `MP3_320`, `MP3_256`, `MP3_128`). progress_callback (callable): A callable that accepts `current` and `bytes` arguments. Returns: Path: The file path of the downloaded track. \"\"\" track . add_more_tags ( self ) bitrate = utils . get_quality ( bitrate ) download_url = utils . get_stream_url ( track , bitrate ) ext = \".flac\" if bitrate == \"9\" else \".mp3\" file_path = utils . get_file_path ( track , ext ) crypt = self . _req . get ( download_url , stream = True ) total = int ( crypt . headers [ \"Content-Length\" ]) current = 0 with file_path . open ( \"wb\" ) as f : for data in utils . decrypt_file ( crypt . iter_content ( 2048 ), track . id ): current += len ( data ) f . write ( data ) if progress_callback : progress_callback ( current , total ) utils . tag ( file_path , track ) return file_path","title":"session.py"},{"location":"reference/session/#deethon.session","text":"This module contains the Session class.","title":"deethon.session"},{"location":"reference/session/#deethon.session.Session","text":"A session is required to connect to Deezer's unofficial API.","title":"Session"},{"location":"reference/session/#deethon.session.Session.__init__","text":"Creates a new Deezer session instance. Parameters: Name Type Description Default arl_token str The arl token is used to make API requests on Deezers unofficial API required Source code in deethon\\session.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 def __init__ ( self , arl_token : str ): \"\"\" Creates a new Deezer session instance. Args: arl_token (str): The arl token is used to make API requests on Deezers unofficial API \"\"\" self . _arl_token : str = arl_token self . _req = requests . Session () self . _req . cookies [ \"arl\" ] = self . _arl_token user = self . get_api ( consts . METHOD_GET_USER ) if user [ \"USER\" ][ \"USER_ID\" ] == 0 : raise errors . DeezerLoginError self . _csrf_token = user [ \"checkForm\" ]","title":"__init__()"},{"location":"reference/session/#deethon.session.Session.download","text":"Downloads the given Deezer url if possible. Parameters: Name Type Description Default url str The URL of the track or album to download. required bitrate str The preferred bitrate to download ( FLAC , MP3_320 , MP3_256 , MP3_128 ). 'FLAC' progress_callback callable A callable that accepts current and bytes arguments. None Returns: Type Description Path The file path of the downloaded track Source code in deethon\\session.py 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 def download ( self , url : str , bitrate : str = \"FLAC\" , progress_callback = None ): \"\"\" Downloads the given Deezer url if possible. Args: url (str): The URL of the track or album to download. bitrate (str, optional): The preferred bitrate to download (`FLAC`, `MP3_320`, `MP3_256`, `MP3_128`). progress_callback (callable): A callable that accepts `current` and `bytes` arguments. Returns: Path: The file path of the downloaded track \"\"\" match = re . match ( r \"https?://(?:www\\.)?deezer\\.com/(?:\\w+/)?(\\w+)/(\\d+)\" , url ) if match : mode = match . group ( 1 ) content_id = match . group ( 2 ) if mode == \"track\" : return self . download_track ( types . Track ( content_id ), bitrate , progress_callback ) if mode == \"album\" : return self . download_album ( types . Album ( content_id ), bitrate ) raise errors . ActionNotSupported ( mode ) else : raise errors . InvalidUrlError ( url )","title":"download()"},{"location":"reference/session/#deethon.session.Session.download_track","text":"Downloads the given [Track][deethon.types.Track] object. Parameters: Name Type Description Default track Track A [Track][deethon.types.Track] instance. required bitrate str The preferred bitrate to download ( FLAC , MP3_320 , MP3_256 , MP3_128 ). 'FLAC' progress_callback callable A callable that accepts current and bytes arguments. None Returns: Type Description Path Path: The file path of the downloaded track. Source code in deethon\\session.py 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def download_track ( self , track : types . Track , bitrate : str = \"FLAC\" , progress_callback = None ) -> Path : \"\"\" Downloads the given [Track][deethon.types.Track] object. Args: track: A [Track][deethon.types.Track] instance. bitrate (optional): The preferred bitrate to download (`FLAC`, `MP3_320`, `MP3_256`, `MP3_128`). progress_callback (callable): A callable that accepts `current` and `bytes` arguments. Returns: Path: The file path of the downloaded track. \"\"\" track . add_more_tags ( self ) bitrate = utils . get_quality ( bitrate ) download_url = utils . get_stream_url ( track , bitrate ) ext = \".flac\" if bitrate == \"9\" else \".mp3\" file_path = utils . get_file_path ( track , ext ) crypt = self . _req . get ( download_url , stream = True ) total = int ( crypt . headers [ \"Content-Length\" ]) current = 0 with file_path . open ( \"wb\" ) as f : for data in utils . decrypt_file ( crypt . iter_content ( 2048 ), track . id ): current += len ( data ) f . write ( data ) if progress_callback : progress_callback ( current , total ) utils . tag ( file_path , track ) return file_path","title":"download_track()"},{"location":"reference/types/","text":"\u00a4 This module contains all available type classes. Album \u00a4 The Album class contains several information about an album. artist: str \u00a4 The main artist of the album. basic_tracks_data: list \u00a4 A list that contains basic tracks data. cover_big: bytes property readonly \u00a4 The album cover in big size cover_big_link: str \u00a4 The link for the album cover in big size cover_medium: bytes property readonly \u00a4 The album cover in medium size cover_medium_link: str \u00a4 The link for the album cover in medium size cover_small: bytes property readonly \u00a4 The album cover in small size cover_small_link: str \u00a4 The link for the album cover in small size. cover_xl: bytes property readonly \u00a4 The album cover in xl size cover_xl_link: str \u00a4 The link for the album cover in xl size duration: int \u00a4 The duration in seconds of the album. genres: list \u00a4 A list of genres of the album. id: int \u00a4 The ID of the album. label: str \u00a4 The label of the album. link: str \u00a4 The Deezer link of the album. record_type: str \u00a4 The record type of the album. release_date: datetime \u00a4 The release date of the album. title: str \u00a4 The title of the album. total_tracks: int \u00a4 The total number of tracks in the album. tracks: list property readonly \u00a4 A list of [Track][deethon.types.Track] objects for each track in the album. upc: str \u00a4 The Universal Product Code (UPC) of the album. __init__ ( self , album_id ) special \u00a4 Create a new album instance with the specified album ID. Parameters: Name Type Description Default album_id int The Deezer album ID. required Exceptions: Type Description DeezerApiError The Deezer API request replied with an error. Source code in deethon\\types.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def __init__ ( self , album_id : int ): \"\"\" Create a new album instance with the specified album ID. Args: album_id (Union[int, str]): The Deezer album ID. Raises: DeezerApiError: The Deezer API request replied with an error. \"\"\" r = requests . get ( f \"https://api.deezer.com/album/ { album_id } \" ) . json () if \"error\" in r : raise errors . DeezerApiError ( r [ 'error' ][ 'type' ], r [ 'error' ][ 'message' ], r [ 'error' ][ 'code' ]) self . artist : str = r [ \"artist\" ][ \"name\" ] \"\"\"The main artist of the album.\"\"\" self . basic_tracks_data : list = r [ \"tracks\" ][ \"data\" ] \"\"\"A list that contains basic tracks data.\"\"\" self . cover_small_link : str = r [ \"cover_small\" ] \"\"\"The link for the album cover in small size.\"\"\" self . cover_medium_link : str = r [ \"cover_medium\" ] \"\"\"The link for the album cover in medium size\"\"\" self . cover_big_link : str = r [ \"cover_big\" ] \"\"\"The link for the album cover in big size\"\"\" self . cover_xl_link : str = r [ \"cover_xl\" ] \"\"\"The link for the album cover in xl size\"\"\" self . duration : int = r [ \"duration\" ] \"\"\"The duration in seconds of the album.\"\"\" self . genres : list = [ genre [ \"name\" ] for genre in r [ \"genres\" ][ \"data\" ]] \"\"\"A list of genres of the album.\"\"\" self . id : int = r [ \"id\" ] \"\"\"The ID of the album.\"\"\" self . label : str = r [ \"label\" ] \"\"\"The label of the album.\"\"\" self . link : str = r [ \"link\" ] \"\"\"The Deezer link of the album.\"\"\" self . record_type : str = r [ \"record_type\" ] \"\"\"The record type of the album.\"\"\" date = r [ \"release_date\" ] self . release_date : datetime = datetime . strptime ( date , '%Y-%m- %d ' ) \"\"\"The release date of the album.\"\"\" self . title : str = r [ \"title\" ] \"\"\"The title of the album.\"\"\" self . total_tracks : int = r [ \"nb_tracks\" ] \"\"\"The total number of tracks in the album.\"\"\" self . upc : str = r [ \"upc\" ] \"\"\"The Universal Product Code (UPC) of the album.\"\"\" self . _cover_small = None self . _cover_medium = None self . _cover_big = None self . _cover_xl = None __new__ ( cls , album_id ) special staticmethod \u00a4 If an album instance with the specified album ID already exists, this method returns the cached instance, otherwise a new album instance is created. Parameters: Name Type Description Default album_id int The Deezer album ID. required Source code in deethon\\types.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def __new__ ( cls , album_id : int ): \"\"\" If an album instance with the specified album ID already exists, this method returns the cached instance, otherwise a new album instance is created. Args: album_id (Union[int, str]): The Deezer album ID. \"\"\" if album_id in cls . _cache . keys (): return cls . _cache [ album_id ] _album = super ( Album , cls ) . __new__ ( cls ) cls . _cache [ album_id ] = _album return _album Track \u00a4 The Track class contains several information about a track. album: Album property readonly \u00a4 Return an Album instance. album_id \u00a4 The Deezer album ID to which the track belongs. artist: str \u00a4 The main artist of the track. author: Optional [ str ] \u00a4 The author of the track. Warning This attribute is only set after [add_more_tags()][deethon.types.Track.add_more_tags] is called. Defaults to None . bpm: int \u00a4 Beats per minute of the track. composer: Optional [ str ] \u00a4 The author of the track. Warning This attribute is only set after [add_more_tags()][deethon.types.Track.add_more_tags] is called. Defaults to None . disk_number: int \u00a4 The disc number of the track. duration: int \u00a4 The duration of the track. id: int \u00a4 The Deezer ID of the track. isrc: str \u00a4 The International Standard Recording Code (ISRC) of the track. link: str \u00a4 The Deezer link of the track. md5_origin: Optional [ str ] \u00a4 The md5 origin of the track. Warning This attribute is only set after [add_more_tags()][deethon.types.Track.add_more_tags] is called. Defaults to None . media_version: Optional [ str ] \u00a4 The media version of the track. Warning This attribute is only set after [add_more_tags()][deethon.types.Track.add_more_tags] is called. Defaults to None . number: int \u00a4 The position of the track. release_date: datetime \u00a4 The release date of the track. replaygain_track_peak: int \u00a4 The Replay Gain value of the track. title: str \u00a4 The title of the track. title_short: str \u00a4 The short title of the track. __init__ ( self , track_id ) special \u00a4 Create a new track instance with the specified track ID. Parameters: Name Type Description Default track_id int The Deezer track ID. required Exceptions: Type Description DeezerApiError The Deezer API request replied with an error. Source code in deethon\\types.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 def __init__ ( self , track_id : int ): \"\"\" Create a new track instance with the specified track ID. Args: track_id (Union[int, str]): The Deezer track ID. Raises: DeezerApiError: The Deezer API request replied with an error. \"\"\" r = requests . get ( f \"https://api.deezer.com/track/ { track_id } \" ) . json () if \"error\" in r : raise errors . DeezerApiError ( r [ 'error' ][ 'type' ], r [ 'error' ][ 'message' ], r [ 'error' ][ 'code' ]) self . artist : str = r [ 'artist' ][ 'name' ] \"\"\"The main artist of the track.\"\"\" self . bpm : int = r [ 'bpm' ] \"\"\"Beats per minute of the track.\"\"\" self . disk_number : int = r [ 'disk_number' ] \"\"\"The disc number of the track.\"\"\" self . duration : int = r [ 'duration' ] \"\"\"The duration of the track.\"\"\" self . id : int = r [ 'id' ] \"\"\"The Deezer ID of the track.\"\"\" self . isrc : str = r [ 'isrc' ] \"\"\"The International Standard Recording Code (ISRC) of the track.\"\"\" self . link : str = r [ 'link' ] \"\"\"The Deezer link of the track.\"\"\" self . number : int = r [ 'track_position' ] \"\"\"The position of the track.\"\"\" self . replaygain_track_peak : int = r [ 'gain' ] \"\"\"The Replay Gain value of the track.\"\"\" date : str = r [ \"release_date\" ] self . release_date : datetime = datetime . strptime ( date , '%Y-%m- %d ' ) \"\"\"The release date of the track.\"\"\" self . title : str = r [ 'title' ] \"\"\"The title of the track.\"\"\" self . title_short : str = r [ 'title_short' ] \"\"\"The short title of the track.\"\"\" self . album_id = r [ 'album' ][ \"id\" ] \"\"\"The Deezer album ID to which the track belongs.\"\"\" self . md5_origin : Optional [ str ] = None \"\"\" The md5 origin of the track. Warning: This attribute is only set after [add_more_tags()][deethon.types.Track.add_more_tags] is called. Defaults to `None`. \"\"\" self . media_version : Optional [ str ] = None \"\"\" The media version of the track. Warning: This attribute is only set after [add_more_tags()][deethon.types.Track.add_more_tags] is called. Defaults to `None`. \"\"\" self . composer : Optional [ str ] = None \"\"\" The author of the track. Warning: This attribute is only set after [add_more_tags()][deethon.types.Track.add_more_tags] is called. Defaults to `None`. \"\"\" self . author : Optional [ str ] = None \"\"\" The author of the track. Warning: This attribute is only set after [add_more_tags()][deethon.types.Track.add_more_tags] is called. Defaults to `None`. \"\"\" __new__ ( cls , track_id ) special staticmethod \u00a4 If a track instance with the specified track ID already exists, this method returns the cached instance, otherwise a new track instance is created and cached. Parameters: Name Type Description Default track_id int The Deezer album ID. required Source code in deethon\\types.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 def __new__ ( cls , track_id : int ): \"\"\" If a track instance with the specified track ID already exists, this method returns the cached instance, otherwise a new track instance is created and cached. Args: track_id (Union[int, str]): The Deezer album ID. \"\"\" if track_id in cls . _cache . keys (): return cls . _cache [ track_id ] track = super ( Track , cls ) . __new__ ( cls ) cls . _cache [ track_id ] = track return track add_more_tags ( self , session ) \u00a4 Adds more tags using Deezer's unofficial API. Parameters: Name Type Description Default session Session A deethon.Session object is required to connect to the Deezer API. required Source code in deethon\\types.py 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 def add_more_tags ( self , session : Session ) -> None : \"\"\" Adds more tags using Deezer's unofficial API. Args: session: A deethon.Session object is required to connect to the Deezer API. \"\"\" track_info = session . get_api ( consts . METHOD_GET_TRACK , session . csrf_token , { \"sng_id\" : self . id }) self . md5_origin = track_info [ \"MD5_ORIGIN\" ] self . media_version = track_info [ \"MEDIA_VERSION\" ] if \"composer\" in track_info [ \"SNG_CONTRIBUTORS\" ]: self . composer = track_info [ \"SNG_CONTRIBUTORS\" ][ \"composer\" ] if \"author\" in track_info [ \"SNG_CONTRIBUTORS\" ]: self . author = track_info [ \"SNG_CONTRIBUTORS\" ][ \"author\" ]","title":"types.py"},{"location":"reference/types/#deethon.types","text":"This module contains all available type classes.","title":"deethon.types"},{"location":"reference/types/#deethon.types.Album","text":"The Album class contains several information about an album.","title":"Album"},{"location":"reference/types/#deethon.types.Album.artist","text":"The main artist of the album.","title":"artist"},{"location":"reference/types/#deethon.types.Album.basic_tracks_data","text":"A list that contains basic tracks data.","title":"basic_tracks_data"},{"location":"reference/types/#deethon.types.Album.cover_big","text":"The album cover in big size","title":"cover_big"},{"location":"reference/types/#deethon.types.Album.cover_big_link","text":"The link for the album cover in big size","title":"cover_big_link"},{"location":"reference/types/#deethon.types.Album.cover_medium","text":"The album cover in medium size","title":"cover_medium"},{"location":"reference/types/#deethon.types.Album.cover_medium_link","text":"The link for the album cover in medium size","title":"cover_medium_link"},{"location":"reference/types/#deethon.types.Album.cover_small","text":"The album cover in small size","title":"cover_small"},{"location":"reference/types/#deethon.types.Album.cover_small_link","text":"The link for the album cover in small size.","title":"cover_small_link"},{"location":"reference/types/#deethon.types.Album.cover_xl","text":"The album cover in xl size","title":"cover_xl"},{"location":"reference/types/#deethon.types.Album.cover_xl_link","text":"The link for the album cover in xl size","title":"cover_xl_link"},{"location":"reference/types/#deethon.types.Album.duration","text":"The duration in seconds of the album.","title":"duration"},{"location":"reference/types/#deethon.types.Album.genres","text":"A list of genres of the album.","title":"genres"},{"location":"reference/types/#deethon.types.Album.id","text":"The ID of the album.","title":"id"},{"location":"reference/types/#deethon.types.Album.label","text":"The label of the album.","title":"label"},{"location":"reference/types/#deethon.types.Album.link","text":"The Deezer link of the album.","title":"link"},{"location":"reference/types/#deethon.types.Album.record_type","text":"The record type of the album.","title":"record_type"},{"location":"reference/types/#deethon.types.Album.release_date","text":"The release date of the album.","title":"release_date"},{"location":"reference/types/#deethon.types.Album.title","text":"The title of the album.","title":"title"},{"location":"reference/types/#deethon.types.Album.total_tracks","text":"The total number of tracks in the album.","title":"total_tracks"},{"location":"reference/types/#deethon.types.Album.tracks","text":"A list of [Track][deethon.types.Track] objects for each track in the album.","title":"tracks"},{"location":"reference/types/#deethon.types.Album.upc","text":"The Universal Product Code (UPC) of the album.","title":"upc"},{"location":"reference/types/#deethon.types.Album.__init__","text":"Create a new album instance with the specified album ID. Parameters: Name Type Description Default album_id int The Deezer album ID. required Exceptions: Type Description DeezerApiError The Deezer API request replied with an error. Source code in deethon\\types.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 def __init__ ( self , album_id : int ): \"\"\" Create a new album instance with the specified album ID. Args: album_id (Union[int, str]): The Deezer album ID. Raises: DeezerApiError: The Deezer API request replied with an error. \"\"\" r = requests . get ( f \"https://api.deezer.com/album/ { album_id } \" ) . json () if \"error\" in r : raise errors . DeezerApiError ( r [ 'error' ][ 'type' ], r [ 'error' ][ 'message' ], r [ 'error' ][ 'code' ]) self . artist : str = r [ \"artist\" ][ \"name\" ] \"\"\"The main artist of the album.\"\"\" self . basic_tracks_data : list = r [ \"tracks\" ][ \"data\" ] \"\"\"A list that contains basic tracks data.\"\"\" self . cover_small_link : str = r [ \"cover_small\" ] \"\"\"The link for the album cover in small size.\"\"\" self . cover_medium_link : str = r [ \"cover_medium\" ] \"\"\"The link for the album cover in medium size\"\"\" self . cover_big_link : str = r [ \"cover_big\" ] \"\"\"The link for the album cover in big size\"\"\" self . cover_xl_link : str = r [ \"cover_xl\" ] \"\"\"The link for the album cover in xl size\"\"\" self . duration : int = r [ \"duration\" ] \"\"\"The duration in seconds of the album.\"\"\" self . genres : list = [ genre [ \"name\" ] for genre in r [ \"genres\" ][ \"data\" ]] \"\"\"A list of genres of the album.\"\"\" self . id : int = r [ \"id\" ] \"\"\"The ID of the album.\"\"\" self . label : str = r [ \"label\" ] \"\"\"The label of the album.\"\"\" self . link : str = r [ \"link\" ] \"\"\"The Deezer link of the album.\"\"\" self . record_type : str = r [ \"record_type\" ] \"\"\"The record type of the album.\"\"\" date = r [ \"release_date\" ] self . release_date : datetime = datetime . strptime ( date , '%Y-%m- %d ' ) \"\"\"The release date of the album.\"\"\" self . title : str = r [ \"title\" ] \"\"\"The title of the album.\"\"\" self . total_tracks : int = r [ \"nb_tracks\" ] \"\"\"The total number of tracks in the album.\"\"\" self . upc : str = r [ \"upc\" ] \"\"\"The Universal Product Code (UPC) of the album.\"\"\" self . _cover_small = None self . _cover_medium = None self . _cover_big = None self . _cover_xl = None","title":"__init__()"},{"location":"reference/types/#deethon.types.Album.__new__","text":"If an album instance with the specified album ID already exists, this method returns the cached instance, otherwise a new album instance is created. Parameters: Name Type Description Default album_id int The Deezer album ID. required Source code in deethon\\types.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def __new__ ( cls , album_id : int ): \"\"\" If an album instance with the specified album ID already exists, this method returns the cached instance, otherwise a new album instance is created. Args: album_id (Union[int, str]): The Deezer album ID. \"\"\" if album_id in cls . _cache . keys (): return cls . _cache [ album_id ] _album = super ( Album , cls ) . __new__ ( cls ) cls . _cache [ album_id ] = _album return _album","title":"__new__()"},{"location":"reference/types/#deethon.types.Track","text":"The Track class contains several information about a track.","title":"Track"},{"location":"reference/types/#deethon.types.Track.album","text":"Return an Album instance.","title":"album"},{"location":"reference/types/#deethon.types.Track.album_id","text":"The Deezer album ID to which the track belongs.","title":"album_id"},{"location":"reference/types/#deethon.types.Track.artist","text":"The main artist of the track.","title":"artist"},{"location":"reference/types/#deethon.types.Track.author","text":"The author of the track. Warning This attribute is only set after [add_more_tags()][deethon.types.Track.add_more_tags] is called. Defaults to None .","title":"author"},{"location":"reference/types/#deethon.types.Track.bpm","text":"Beats per minute of the track.","title":"bpm"},{"location":"reference/types/#deethon.types.Track.composer","text":"The author of the track. Warning This attribute is only set after [add_more_tags()][deethon.types.Track.add_more_tags] is called. Defaults to None .","title":"composer"},{"location":"reference/types/#deethon.types.Track.disk_number","text":"The disc number of the track.","title":"disk_number"},{"location":"reference/types/#deethon.types.Track.duration","text":"The duration of the track.","title":"duration"},{"location":"reference/types/#deethon.types.Track.id","text":"The Deezer ID of the track.","title":"id"},{"location":"reference/types/#deethon.types.Track.isrc","text":"The International Standard Recording Code (ISRC) of the track.","title":"isrc"},{"location":"reference/types/#deethon.types.Track.link","text":"The Deezer link of the track.","title":"link"},{"location":"reference/types/#deethon.types.Track.md5_origin","text":"The md5 origin of the track. Warning This attribute is only set after [add_more_tags()][deethon.types.Track.add_more_tags] is called. Defaults to None .","title":"md5_origin"},{"location":"reference/types/#deethon.types.Track.media_version","text":"The media version of the track. Warning This attribute is only set after [add_more_tags()][deethon.types.Track.add_more_tags] is called. Defaults to None .","title":"media_version"},{"location":"reference/types/#deethon.types.Track.number","text":"The position of the track.","title":"number"},{"location":"reference/types/#deethon.types.Track.release_date","text":"The release date of the track.","title":"release_date"},{"location":"reference/types/#deethon.types.Track.replaygain_track_peak","text":"The Replay Gain value of the track.","title":"replaygain_track_peak"},{"location":"reference/types/#deethon.types.Track.title","text":"The title of the track.","title":"title"},{"location":"reference/types/#deethon.types.Track.title_short","text":"The short title of the track.","title":"title_short"},{"location":"reference/types/#deethon.types.Track.__init__","text":"Create a new track instance with the specified track ID. Parameters: Name Type Description Default track_id int The Deezer track ID. required Exceptions: Type Description DeezerApiError The Deezer API request replied with an error. Source code in deethon\\types.py 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 def __init__ ( self , track_id : int ): \"\"\" Create a new track instance with the specified track ID. Args: track_id (Union[int, str]): The Deezer track ID. Raises: DeezerApiError: The Deezer API request replied with an error. \"\"\" r = requests . get ( f \"https://api.deezer.com/track/ { track_id } \" ) . json () if \"error\" in r : raise errors . DeezerApiError ( r [ 'error' ][ 'type' ], r [ 'error' ][ 'message' ], r [ 'error' ][ 'code' ]) self . artist : str = r [ 'artist' ][ 'name' ] \"\"\"The main artist of the track.\"\"\" self . bpm : int = r [ 'bpm' ] \"\"\"Beats per minute of the track.\"\"\" self . disk_number : int = r [ 'disk_number' ] \"\"\"The disc number of the track.\"\"\" self . duration : int = r [ 'duration' ] \"\"\"The duration of the track.\"\"\" self . id : int = r [ 'id' ] \"\"\"The Deezer ID of the track.\"\"\" self . isrc : str = r [ 'isrc' ] \"\"\"The International Standard Recording Code (ISRC) of the track.\"\"\" self . link : str = r [ 'link' ] \"\"\"The Deezer link of the track.\"\"\" self . number : int = r [ 'track_position' ] \"\"\"The position of the track.\"\"\" self . replaygain_track_peak : int = r [ 'gain' ] \"\"\"The Replay Gain value of the track.\"\"\" date : str = r [ \"release_date\" ] self . release_date : datetime = datetime . strptime ( date , '%Y-%m- %d ' ) \"\"\"The release date of the track.\"\"\" self . title : str = r [ 'title' ] \"\"\"The title of the track.\"\"\" self . title_short : str = r [ 'title_short' ] \"\"\"The short title of the track.\"\"\" self . album_id = r [ 'album' ][ \"id\" ] \"\"\"The Deezer album ID to which the track belongs.\"\"\" self . md5_origin : Optional [ str ] = None \"\"\" The md5 origin of the track. Warning: This attribute is only set after [add_more_tags()][deethon.types.Track.add_more_tags] is called. Defaults to `None`. \"\"\" self . media_version : Optional [ str ] = None \"\"\" The media version of the track. Warning: This attribute is only set after [add_more_tags()][deethon.types.Track.add_more_tags] is called. Defaults to `None`. \"\"\" self . composer : Optional [ str ] = None \"\"\" The author of the track. Warning: This attribute is only set after [add_more_tags()][deethon.types.Track.add_more_tags] is called. Defaults to `None`. \"\"\" self . author : Optional [ str ] = None \"\"\" The author of the track. Warning: This attribute is only set after [add_more_tags()][deethon.types.Track.add_more_tags] is called. Defaults to `None`. \"\"\"","title":"__init__()"},{"location":"reference/types/#deethon.types.Track.__new__","text":"If a track instance with the specified track ID already exists, this method returns the cached instance, otherwise a new track instance is created and cached. Parameters: Name Type Description Default track_id int The Deezer album ID. required Source code in deethon\\types.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 def __new__ ( cls , track_id : int ): \"\"\" If a track instance with the specified track ID already exists, this method returns the cached instance, otherwise a new track instance is created and cached. Args: track_id (Union[int, str]): The Deezer album ID. \"\"\" if track_id in cls . _cache . keys (): return cls . _cache [ track_id ] track = super ( Track , cls ) . __new__ ( cls ) cls . _cache [ track_id ] = track return track","title":"__new__()"},{"location":"reference/types/#deethon.types.Track.add_more_tags","text":"Adds more tags using Deezer's unofficial API. Parameters: Name Type Description Default session Session A deethon.Session object is required to connect to the Deezer API. required Source code in deethon\\types.py 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 def add_more_tags ( self , session : Session ) -> None : \"\"\" Adds more tags using Deezer's unofficial API. Args: session: A deethon.Session object is required to connect to the Deezer API. \"\"\" track_info = session . get_api ( consts . METHOD_GET_TRACK , session . csrf_token , { \"sng_id\" : self . id }) self . md5_origin = track_info [ \"MD5_ORIGIN\" ] self . media_version = track_info [ \"MEDIA_VERSION\" ] if \"composer\" in track_info [ \"SNG_CONTRIBUTORS\" ]: self . composer = track_info [ \"SNG_CONTRIBUTORS\" ][ \"composer\" ] if \"author\" in track_info [ \"SNG_CONTRIBUTORS\" ]: self . author = track_info [ \"SNG_CONTRIBUTORS\" ][ \"author\" ]","title":"add_more_tags()"},{"location":"reference/utils/","text":"\u00a4 The utils module contains several useful functions that are used within the package. decrypt_file ( input_data , track_id ) \u00a4 Decrypt an encrypted track. Parameters: Name Type Description Default input_data Iterator The input stream must have a chunk size of 2048. required track_id int The id of the track to be decrypted. required Returns: Type Description Generator[bytes, Any, None] A Generator object containing the decrypted data Source code in deethon\\utils.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def decrypt_file ( input_data : Iterator , track_id : int ) -> Generator [ bytes , Any , None ]: \"\"\" Decrypt an encrypted track. Args: input_data: The input stream must have a chunk size of 2048. track_id: The id of the track to be decrypted. Returns: A Generator object containing the decrypted data \"\"\" h = _md5hex ( str ( track_id ) . encode ()) key = \"\" . join ( chr ( h [ i ] ^ h [ i + 16 ] ^ b \"g4el58wc0zvf9na1\" [ i ]) for i in range ( 16 )) seg = 0 for data in input_data : if not data : break if ( seg % 3 ) == 0 and len ( data ) == 2048 : data = Blowfish . new ( key . encode (), Blowfish . MODE_CBC , a2b_hex ( \"0001020304050607\" )) . decrypt ( data ) seg += 1 yield data get_file_path ( track , ext ) \u00a4 Generate a file path using a Track object. Parameters: Name Type Description Default track Track A Track object. required ext The file extension to be used. required Returns: Type Description Path A Path object containing the track path. Source code in deethon\\utils.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def get_file_path ( track : Track , ext ) -> Path : \"\"\" Generate a file path using a Track object. Args: track: A Track object. ext: The file extension to be used. Returns: A Path object containing the track path. \"\"\" std_dir = \"Songs/\" dir_path = Path ( f \" { std_dir }{ track . album . artist } / { track . album . title } \" ) dir_path . mkdir ( parents = True , exist_ok = True ) file_name = f \" { track . number } - { track . title }{ ext } \" return dir_path / file_name get_stream_url ( track , quality ) \u00a4 Get the direct download url for the encrypted track. Parameters: Name Type Description Default track Track A [Track][deethon.types.Track] instance. required quality str The preferred quality. required Returns: Type Description str The direct download url. Source code in deethon\\utils.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def get_stream_url ( track : Track , quality : str ) -> str : \"\"\" Get the direct download url for the encrypted track. Args: track: A [Track][deethon.types.Track] instance. quality: The preferred quality. Returns: The direct download url. \"\"\" data = b \" \\xa4 \" . join ( a . encode () for a in [ track . md5_origin , quality , str ( track . id ), str ( track . media_version )]) data = b \" \\xa4 \" . join ([ _md5hex ( data ), data ]) + b \" \\xa4 \" if len ( data ) % 16 : data += b \" \\x00 \" * ( 16 - len ( data ) % 16 ) c = AES . new ( \"jo6aey6haid2Teih\" . encode (), AES . MODE_ECB ) hashs = b2a_hex ( c . encrypt ( data )) . decode () return f \"https://e-cdns-proxy- { track . md5_origin [ 0 ] } .dzcdn.net/mobile/1/ { hashs } \" tag ( file_path , track ) \u00a4 Tag the music file at the given file path using the specified [Track][deethon.types.Track] instance. Parameters: Name Type Description Default file_path Path The music file to be tagged required track Track The [Track][deethon.types.Track] instance to be used for tagging. required Source code in deethon\\utils.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def tag ( file_path : Path , track : Track ) -> None : \"\"\" Tag the music file at the given file path using the specified [Track][deethon.types.Track] instance. Args: file_path (Path): The music file to be tagged track: The [Track][deethon.types.Track] instance to be used for tagging. \"\"\" ext = file_path . suffix if ext == \".mp3\" : tags = ID3 () tags . add ( Frames [ 'TALB' ]( encoding = 3 , text = track . album . title )) tags . add ( Frames [ 'TBPM' ]( encoding = 3 , text = str ( track . bpm ))) tags . add ( Frames [ 'TCON' ]( encoding = 3 , text = track . album . genres )) tags . add ( Frames [ 'TDAT' ]( encoding = 3 , text = track . release_date . strftime ( ' %d %m' ))) tags . add ( Frames [ 'TIT2' ]( encoding = 3 , text = track . title )) tags . add ( Frames [ 'TPE1' ]( encoding = 3 , text = track . artist )) tags . add ( Frames [ 'TPE2' ]( encoding = 3 , text = track . album . artist )) tags . add ( Frames [ 'TPOS' ]( encoding = 3 , text = str ( track . disk_number ))) tags . add ( Frames [ 'TPUB' ]( encoding = 3 , text = track . album . label )) tags . add ( Frames [ 'TRCK' ]( encoding = 3 , text = f \" { track . number } / { track . album . total_tracks } \" )) tags . add ( Frames [ 'TSRC' ]( encoding = 3 , text = track . isrc )) tags . add ( Frames [ 'TYER' ]( encoding = 3 , text = str ( track . release_date . year ))) tags . add ( Frames [ 'TXXX' ]( encoding = 3 , desc = \"replaygain_track_peak\" , text = str ( track . replaygain_track_peak ), )) tags . add ( Frames [ 'APIC' ]( encoding = 3 , mime = \"image/jpeg\" , type = 3 , desc = \"Cover\" , data = track . album . cover_xl , )) tags . save ( file_path , v2_version = 3 ) else : tags = FLAC ( file_path ) tags [ \"album\" ] = track . album . title tags [ \"albumartist\" ] = track . album . artist tags [ \"artist\" ] = track . artist tags [ \"bpm\" ] = str ( track . bpm ) tags [ \"genre\" ] = track . album . genres tags [ \"isrc\" ] = track . isrc tags [ \"replaygain_track_peak\" ] = str ( track . replaygain_track_peak ) tags [ \"title\" ] = track . title tags [ \"tracknumber\" ] = str ( track . number ) cover = Picture () cover . type = 3 cover . data = track . album . cover_xl cover . width = 1000 cover . height = 1000 tags . clear_pictures () tags . add_picture ( cover ) tags . save ()","title":"utils.py"},{"location":"reference/utils/#deethon.utils","text":"The utils module contains several useful functions that are used within the package.","title":"deethon.utils"},{"location":"reference/utils/#deethon.utils.decrypt_file","text":"Decrypt an encrypted track. Parameters: Name Type Description Default input_data Iterator The input stream must have a chunk size of 2048. required track_id int The id of the track to be decrypted. required Returns: Type Description Generator[bytes, Any, None] A Generator object containing the decrypted data Source code in deethon\\utils.py 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def decrypt_file ( input_data : Iterator , track_id : int ) -> Generator [ bytes , Any , None ]: \"\"\" Decrypt an encrypted track. Args: input_data: The input stream must have a chunk size of 2048. track_id: The id of the track to be decrypted. Returns: A Generator object containing the decrypted data \"\"\" h = _md5hex ( str ( track_id ) . encode ()) key = \"\" . join ( chr ( h [ i ] ^ h [ i + 16 ] ^ b \"g4el58wc0zvf9na1\" [ i ]) for i in range ( 16 )) seg = 0 for data in input_data : if not data : break if ( seg % 3 ) == 0 and len ( data ) == 2048 : data = Blowfish . new ( key . encode (), Blowfish . MODE_CBC , a2b_hex ( \"0001020304050607\" )) . decrypt ( data ) seg += 1 yield data","title":"decrypt_file()"},{"location":"reference/utils/#deethon.utils.get_file_path","text":"Generate a file path using a Track object. Parameters: Name Type Description Default track Track A Track object. required ext The file extension to be used. required Returns: Type Description Path A Path object containing the track path. Source code in deethon\\utils.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def get_file_path ( track : Track , ext ) -> Path : \"\"\" Generate a file path using a Track object. Args: track: A Track object. ext: The file extension to be used. Returns: A Path object containing the track path. \"\"\" std_dir = \"Songs/\" dir_path = Path ( f \" { std_dir }{ track . album . artist } / { track . album . title } \" ) dir_path . mkdir ( parents = True , exist_ok = True ) file_name = f \" { track . number } - { track . title }{ ext } \" return dir_path / file_name","title":"get_file_path()"},{"location":"reference/utils/#deethon.utils.get_stream_url","text":"Get the direct download url for the encrypted track. Parameters: Name Type Description Default track Track A [Track][deethon.types.Track] instance. required quality str The preferred quality. required Returns: Type Description str The direct download url. Source code in deethon\\utils.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def get_stream_url ( track : Track , quality : str ) -> str : \"\"\" Get the direct download url for the encrypted track. Args: track: A [Track][deethon.types.Track] instance. quality: The preferred quality. Returns: The direct download url. \"\"\" data = b \" \\xa4 \" . join ( a . encode () for a in [ track . md5_origin , quality , str ( track . id ), str ( track . media_version )]) data = b \" \\xa4 \" . join ([ _md5hex ( data ), data ]) + b \" \\xa4 \" if len ( data ) % 16 : data += b \" \\x00 \" * ( 16 - len ( data ) % 16 ) c = AES . new ( \"jo6aey6haid2Teih\" . encode (), AES . MODE_ECB ) hashs = b2a_hex ( c . encrypt ( data )) . decode () return f \"https://e-cdns-proxy- { track . md5_origin [ 0 ] } .dzcdn.net/mobile/1/ { hashs } \"","title":"get_stream_url()"},{"location":"reference/utils/#deethon.utils.tag","text":"Tag the music file at the given file path using the specified [Track][deethon.types.Track] instance. Parameters: Name Type Description Default file_path Path The music file to be tagged required track Track The [Track][deethon.types.Track] instance to be used for tagging. required Source code in deethon\\utils.py 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def tag ( file_path : Path , track : Track ) -> None : \"\"\" Tag the music file at the given file path using the specified [Track][deethon.types.Track] instance. Args: file_path (Path): The music file to be tagged track: The [Track][deethon.types.Track] instance to be used for tagging. \"\"\" ext = file_path . suffix if ext == \".mp3\" : tags = ID3 () tags . add ( Frames [ 'TALB' ]( encoding = 3 , text = track . album . title )) tags . add ( Frames [ 'TBPM' ]( encoding = 3 , text = str ( track . bpm ))) tags . add ( Frames [ 'TCON' ]( encoding = 3 , text = track . album . genres )) tags . add ( Frames [ 'TDAT' ]( encoding = 3 , text = track . release_date . strftime ( ' %d %m' ))) tags . add ( Frames [ 'TIT2' ]( encoding = 3 , text = track . title )) tags . add ( Frames [ 'TPE1' ]( encoding = 3 , text = track . artist )) tags . add ( Frames [ 'TPE2' ]( encoding = 3 , text = track . album . artist )) tags . add ( Frames [ 'TPOS' ]( encoding = 3 , text = str ( track . disk_number ))) tags . add ( Frames [ 'TPUB' ]( encoding = 3 , text = track . album . label )) tags . add ( Frames [ 'TRCK' ]( encoding = 3 , text = f \" { track . number } / { track . album . total_tracks } \" )) tags . add ( Frames [ 'TSRC' ]( encoding = 3 , text = track . isrc )) tags . add ( Frames [ 'TYER' ]( encoding = 3 , text = str ( track . release_date . year ))) tags . add ( Frames [ 'TXXX' ]( encoding = 3 , desc = \"replaygain_track_peak\" , text = str ( track . replaygain_track_peak ), )) tags . add ( Frames [ 'APIC' ]( encoding = 3 , mime = \"image/jpeg\" , type = 3 , desc = \"Cover\" , data = track . album . cover_xl , )) tags . save ( file_path , v2_version = 3 ) else : tags = FLAC ( file_path ) tags [ \"album\" ] = track . album . title tags [ \"albumartist\" ] = track . album . artist tags [ \"artist\" ] = track . artist tags [ \"bpm\" ] = str ( track . bpm ) tags [ \"genre\" ] = track . album . genres tags [ \"isrc\" ] = track . isrc tags [ \"replaygain_track_peak\" ] = str ( track . replaygain_track_peak ) tags [ \"title\" ] = track . title tags [ \"tracknumber\" ] = str ( track . number ) cover = Picture () cover . type = 3 cover . data = track . album . cover_xl cover . width = 1000 cover . height = 1000 tags . clear_pictures () tags . add_picture ( cover ) tags . save ()","title":"tag()"}]}